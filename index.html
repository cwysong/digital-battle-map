<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DND Battle Map</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
        }
        #canvasContainer {
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #canvas {
            border: 1px solid black;
            cursor: crosshair;
            image-rendering: pixelated; /* Maintain pixelated look */
        }
        .menu-bar {
            background-color: #333;
            color: white;
            padding: 10px;
            width: 100%;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000; /* Ensure it's above canvas */
            display: flex;
            justify-content: space-between;
        }
        .menu-bar a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
            cursor: pointer;
        }
        .menu-bar a:hover {
            background-color: #555;
        }
    </style>
</head>
<body>
    <div class="menu-bar">
        <div>
            <a href="#" id="addEntity">Add Entity</a>
            <a href="#" id="clearMarks">Clear Marks</a>
        </div>
        <div>
            <a href="#" id="closeApp">Close</a>
        </div>
    </div>

    <div id="canvasContainer">
        <canvas id="canvas"></canvas>
    </div>
    
    <script>
        // Constants for grid size and scrolling amount
        const CELL_SIZE = 60;  // Size of each cell in pixels
        const SCROLL_AMOUNT = 60;  // Amount to scroll on each key press (adjusted for VS Code scale)

        // Variables for canvas and context
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let entities = {};  // Dictionary to store entities
        let selectedEntity = null;  // Variable to store currently selected entity
        let marks = [];  // Array to store marked cells

        // Load background image
        let background = new Image();
        background.src = 'cave.jpg';  // Replace with your image file path

        // Function to draw the grid
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);
            
            // Draw grid lines
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            for (let x = 0; x <= canvas.width; x += CELL_SIZE) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for (let y = 0; y <= canvas.height; y += CELL_SIZE) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();
        }

        // Function to handle mouse click events
        function handleClick(event) {
            let rect = canvas.getBoundingClientRect();
            let mouseX = event.clientX - rect.left;
            let mouseY = event.clientY - rect.top;
            
            let cellX = Math.floor(mouseX / CELL_SIZE) * CELL_SIZE;
            let cellY = Math.floor(mouseY / CELL_SIZE) * CELL_SIZE;

            // Toggle mark on left click, select entity on right click
            if (event.button === 0) {
                toggleMark(cellX, cellY);
            } else if (event.button === 2) {
                selectEntity(cellX, cellY);
            }
        }

        // Function to toggle mark on a cell
        function toggleMark(cellX, cellY) {
            let index = marks.findIndex(mark => mark[0] === cellX && mark[1] === cellY);
            if (index === -1) {
                marks.push([cellX, cellY]);
            } else {
                marks.splice(index, 1);
            }
            redrawCanvas();
        }

        // Function to select an entity
        function selectEntity(cellX, cellY) {
            for (let key in entities) {
                let entity = entities[key];
                if (entity.location[0] === cellX && entity.location[1] === cellY) {
                    if (selectedEntity === entity) {
                        selectedEntity = null;
                    } else {
                        selectedEntity = entity;
                    }
                    redrawCanvas();
                    return;
                }
            }
        }

        // Function to redraw canvas
        function redrawCanvas() {
            drawGrid();
            marks.forEach(mark => {
                ctx.strokeStyle = 'white';
                ctx.strokeRect(mark[0], mark[1], CELL_SIZE, CELL_SIZE);
            });
            for (let key in entities) {
                let entity = entities[key];
                ctx.drawImage(entity.photo, entity.location[0], entity.location[1], CELL_SIZE, CELL_SIZE);
                if (selectedEntity === entity) {
                    ctx.strokeStyle = 'red';
                    ctx.strokeRect(entity.location[0], entity.location[1], CELL_SIZE, CELL_SIZE);
                }
            }
        }

        // Function to handle key press events (scrolling)
        function handleKeyPress(event) {
            switch (event.key) {
                case 'w':
                    canvas.scrollBy(0, -SCROLL_AMOUNT);
                    break;
                case 'a':
                    canvas.scrollBy(-SCROLL_AMOUNT, 0);
                    break;
                case 's':
                    canvas.scrollBy(0, SCROLL_AMOUNT);
                    break;
                case 'd':
                    canvas.scrollBy(SCROLL_AMOUNT, 0);
                    break;
            }
        }

        // Function to add a new entity
        function addEntity(name, sprite, x, y) {
            let entity = {
                name: name,
                photo: new Image(),
                location: [x, y]
            };
            entity.photo.src = sprite;
            entities[name] = entity;
            redrawCanvas();
        }

        // Function to clear all marks
        function clearMarks() {
            marks = [];
            redrawCanvas();
        }

        // Function to close the application
        function closeApp() {
            if (confirm("Are you sure you want to close?")) {
                window.close();
            }
        }

        // Initialize canvas and set up event listeners
        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawGrid();
            canvas.addEventListener('mousedown', handleClick);
            window.addEventListener('keydown', handleKeyPress);

            // Menu bar event listeners
            document.getElementById('addEntity').addEventListener('click', function() {
                // Example: Add entity at specific location
                addEntity('kobold', 'kobold.png', 120, 120);
            });
            document.getElementById('clearMarks').addEventListener('click', function() {
                clearMarks();
            });
            document.getElementById('closeApp').addEventListener('click', function() {
                closeApp();
            });
        }

        // Call init function when the page is loaded
        window.onload = init;
    </script>
</body>
</html>